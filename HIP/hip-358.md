---
hip: 358
title: Allow Token Create Through Hedera Token Service Precompiled Contract
author: Stoyan Panayotov <stoyan.panayotov@limechain.tech>
type: Standards Track
category: Service
needs-council-approval: Yes
status: Review
created: 2022-02-09
discussions-to: https://github.com/hashgraph/hedera-improvement-proposal/discussions/375
updated: 
---

## Abstract

Describe the integration of Hedera Token Service (HTS) with the Hedera Smart 
Contract Service (HSCS), allowing contracts to create tokens programmatically.

## Motivation

Allow smart contract developers on Hedera to create tokens through the HTS 
precompiled contract.

## Rationale

HIP-206 already allows token mint, burn, associate, dissociate and transfer 
through the HTS precompiled contract. Allowing creation of tokens via smart 
contracts is a natural extension of the precompiled contract and would enable 
to rely solely on contract code for token management. 

## User stories

As a smart contract developer, I want to be able to create Hedera tokens through 
solidity contract calls.

## Specification

### EVM Precompile extension

The [Solidity file for development](../assets/hip-206/solidity/IHederaTokenService.sol) 
is updated with new types and function signatures that the precompile will respond to. 
It is included in this HIP by reference.

### Solidity Function Signatures 

Two functions will be added for creating fungible and non-fungible tokens each.
One will be a simple version with just the required fields and the other a version 
supporting custom fees as well. 
The following structs will be added to simplify the interface between solidity 
contract developers and the HTS precompile: 

| Name                | Definition                                                                  |
| ------------------- | ----------------------------------------------------------------------------|
| `KeyValue`          | `(bool, address, bytes, bytes, address)`                                    |
| `Expiry`            | `(uint, address, uint)`                                                     |
| `TokenKey`          | `(uint, KeyValue)`                                                          |
| `ThresholdTokenKey` | `(uint, uint, KeyValue[])`                                                  |
| `HederaToken`       | `(string, string, address, string, bool, uint32, bool, TokenKey[], Expiry)` |
| `FixedFee`          | `(uint32, address, address)`                                                |
| `FractionalFee`     | `(uint32, uint32, uint32, uint32, bool, address)`                           |
| `RoyaltyFee`        | `(uint32, uint32, FixedFee, address)`                                       |

The ABI signature and hashes for each call are as follows:

| hash       | effective signature                                                                       | return                   |
| ---------- | ------------------------------------------------------------------------------------------|--------------------------|
| `7812a04b` | `createFungibleToken(HederaToken, uint, uint)`                                            | `(bool, addess, bytes)`  |
| `4b37e995` | `createFungibleTokenWithCustomFees(HederaToken, uint, uint, FixedFee[], FractionalFee[])` | `(bool, addess, bytes)`  |
| `9dc711e0` | `createNonFungibleToken(HederaToken, uint, uint)`                                         | `(bool, addess, bytes)`  |
| `9c1fba6b` | `createNonFungibleTokenWithCustomFees(HederaToken, uint, uint, FixedFee[], RoyaltyFee[])` | `(bool, addess, bytes)`  |

### Precompile Gas Costs

Gas will be priced so that it will be cheaper to do calls directly to HTS rather
than through HSCS where such calls are possible.

| Function                 | Base Cost |  Incremental Cost |
| ------------------------ | --------: | ----------------: |
| Create                   |    xx Gas |             0 Gas |
| Create with Fees         |    xx Gas |      xx Gas / Fee |

### Precompile Transaction Records

Child records for Token Create or Token Update will be created for each precompile call.


## Backwards Compatibility

There are no changes to the protobufs.
The changes in the existing HTS precompile only add new features and capabilities 
and should not impact existing behaviour.

## Security Implications

This HIP does not change the implementation of HTS token create, nor does it 
add new features. What is being added is a new way to call existing 
functionality. The security posture of the system is expected to remain 
unchanged.

## How to Teach This

The `IHederaTokenService.sol` interface is well documented and example client code 
is provided in `TokenCreateContract.sol`.

## Reference Implementation



## Rejected Ideas

### Support for Complex Keys

This HIP only supports simple 1 of 1 and contract keys for authorization, and 
does not support threshold or other complex key structures.
There are multiple reasons.  First, solidity does not allow for recursive 
structure definitions like protobufs do. This recursive definition is essential
to the complex key structures supported by the protobuf APIs. Second, allowing
even one level of threshold signatures increases the size of the ABI 
significantly for a feature that would burden uses of the API that do not use 
threshold key arrangements.
It is possible that HTS update calls may be added to the HTS precompile, and it 
would partially address this shortcoming. In the interim the protbuf API provides 
full access to complex keys.

## Open Issues



## References

- [Hedera Token Service Developer Docs](https://docs.hedera.com/guides/docs/hedera-api/token-service)
- Solidity Support Code
  - [Response Codes](https://github.com/hashgraph/hedera-smart-contracts/blob/main/hts-precompile/HederaResponseCodes.sol)
  - [Interface ABI Calculations](https://github.com/hashgraph/hedera-smart-contracts/blob/main/hts-precompile/IHederaTokenService.sol)
  - [Helper Class](https://github.com/hashgraph/hedera-smart-contracts/blob/main/hts-precompile/HederaTokenService.sol) to avoid Solidity's EXTCODESIZE check.

## Copyright/license

This document is licensed under the Apache License, Version 2.0 -- see [LICENSE](../LICENSE) or (https://www.apache.org/licenses/LICENSE-2.0)
