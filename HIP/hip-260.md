---
hip: 260 
title: Smart Contract Traceability 
author: Danno Ferrin <danno.ferrin@hedera.com>
type: Standards Track 
category: Service
needs-council-approval: Yes
status: Accepted
last-call-date-time: 2021-12-21T07:00:00Z
created: 2021-12-02
discussions-to: https://github.com/hashgraph/hedera-improvement-proposal/discussions/262
updated: 2021-12-07, 2021-12-14, 2022-05-30
requires: 206, 435
---

## Abstract

Proposes additional data placed in sidecar transaction records to enable full 
replay of transactions by mirror nodes and downstream users of Hedera.

## Motivation

Enabling full replay of smart contract service transactions will improve the
usability, auditability, and debuggability of smart contract service
transactions. Current facilities are insufficient to inspect "internal"
transactions executed across contracts, and provide insufficient error messages
when correcting errors during smart contract development.

## Rationale

[HIP-435](./hip-435.md) allows the creation of sidecar record files containing
detailed information about transaction executions without bloating the main
transaction record stream. This allows us to externalise verbose debug information
about smart contract transactions that was previously expensive to download and 
process every time.

We will introduce a couple of sidecar record types, one containing the minimum 
needed data that allows a user to fully replay the transaction and derive the same 
set of results, and the other containing an entire operation-by-operation trace.

We also need to presume that the user does not have access to the full historical 
state of the chain. However, we do presume some access to select immutable data 
such as the bytecode of the contracts that are called as part of the transaction.

This will allow for the same level of transaction inspection that popular ethereum 
chains have on their block explorer sites without requiring speculative calculation 
of traces from transient execution data.

## User stories

As a user of a mirror node I want to be able to see a list of state changes, a
full representation of the calls between contracts, and a step by step
evaluation of all EVM operations. I want to be able to create these records
disconnected from the Hedera Network with only the record streams of the
transactions.

## Specification

### Add ContractStateChange sidecar record type

Add and populate a new sidecar record of type `ContractStateChanges`. It will
have a single field - repeated `ContractStateChange`, which will be populated 
whenever a transaction causes contract storage states to change.
This field will include the changes across all contract storage and not just the
initial contract in the transaction.

```
message ContractStateChanges {
  repeated ContractStateChange contract_state_changes = 1;
}

/**
 * The storage changes to a smart contract's storage as a side effect of the function call.
 */
message ContractStateChange {

    /**
     * The contract to which the storage changes apply to
     */
    ContractID contractID = 1;

    /**
     * The list of storage changes.
     */
    repeated StorageChange storageChanges = 2;
}

message StorageChange {
    bytes slot = 1;
    bytes valueRead = 2;
    google.protobuf.BytesValue valueWritten = 3;
}
```

For each slot read or written by the smart contract transaction
a `ContactStateChange` record should be added to the transaction record. As
there can be multiple contracts called in one transaction the storage is grouped
by contract.

The `slot`, `valueRead`, and `valueWritten` values are byte strings of up to 32
bytes. Semantically they are `uint256` stored in big endian notation and they
will have leading zero bytes stripped. Hence, any value less than 32 bytes is
semantically identical to a value left padded with zeros.

A slot that is only read and not updated MUST omit the `valueWritten` field.

Values that are updated without first being read must have their `valueRead`
field set regardless. This is required as gas calculation is dependent on the
original value of the field updated. A message without a `valueRead` field will
be treated as though a value of zero had been read, as that is what will be
encoded.

Canonically the fields are sorted by the `contractID` then by slot. Contracts
addressed by account alias (when supported) will sort after accounts addressed
by `contractID`. Canonically the `slot`, `valueRead`, and `valueWritten` are
stripped of preceding zero bytes. Because of this zero values will not be
written by the protobuf encoder. Hence, a contract that reads and writes zeros
to slot zero will have a message with only an empty `valueWritten` field and a
contract that only reads a zero value from slot zero will have an empty message.

The value in `valueRead` reflects the storage value prior to the execution of
the smart contract. The value in `valueWritten`, if present, represents the
final updated value of the storage slot after the completion of the smart
contract call. Transient states between the start and finish of the contract are
not stored in the record stream.

### Add ContractAction sidecar record type

```
/**
 * The type of action described by the action proto.
 */
enum ContractActionType {
    /**
     * default non-value.
     */
    NoAction = 0;

    /**
     * Most CALL, CALLCODE, DELEGATECALL, and STATICCALL, and first action of ContractCall/ContractCallLocal to deployed
     * contracts. This does not include calls to system or precompiled contracts.
     */
    Call = 1;

    /**
     * CREATE, CREATE2, and first action of ContractCreate.
     */

    Create = 2;

    /**
     * like Call, but to precompiled contracts (0x1 to 0x9 as of Berlin)
     */
    Precompile = 3;

    /**
     * Call, but to system contract like HTS or ERC20 facades over Token accounts
     */
    System = 4;
}

/**
 * A finder grained action with a function result. Sometimes called "internal transactions." The function call itself
 * will be the first action in a list, followed by sub-action in the order they were executed.
 */
message ContractAction {

    /**
     * The type of this action.
     */
    ContractActionType callType = 1;

    /**
     * Only the first action can come from an account, the rest will come from contracts.  Because of DELEGATECALL
     * and CALLCODE the caller of actions whose parent is an account may also be an account.
     */
    oneof caller {
        /**
         * If the caller was a regular account, the AccountID.
         */
        AccountID callingAccount = 2;

        /**
         * If the caller was a smart contract account, the ContractID.
         */
        ContractID callingContract = 3;
    }

    /**
     * Gas given to this action, the upper limit of gas this action can spend.
     */
    uint64 gas = 4;

    /**
     * Bytes passed in as input data to this action.
     */
    bytes input = 5;

    /**
     * Who this action is directed to.
     */
    oneof recipient {
        /**
         * The AccountID of the recipient if the recipient is an account. Only HBars will be transferred, no other side
         * effects should be expected.
         */
        AccountID recipientAccount = 6;

        /**
         * The ContractID of the recipient if the recipient is a smart contract.
         */
        ContractID recipientContract = 7;

        /**
         * If the action was directed at an invalid solidity address, what that address was.
         */
        bytes invalidSolidityAddress = 8;
    }

    /**
     * The value (int tinybars) that is associated with this action.
     */
    int64 value = 9;

    /**
     * The actual gas spent by this action.
     */
    uint64 gasUsed = 10;

    /**
     * Was the action successful?
     */
    bool success = 11;

    /**
     * The result data of the action.
     */
    oneof resultData {

        /**
         * If successful, the output bytes of the action.
         */
        bytes output = 12;

        /**
         * The contract itself cause the transaction to fail via the `REVERT` operation
         */
        bytes revertReason = 13;

        /**
         * The transaction itself failed without an explicit `REVERT`
         */
        bytes error = 14;
    }

    /**
     * The nesting depth of this call. The original action is at depth=0.
     */
    uint32 callDepth = 15;
}
```

### Populating `contractCallResult` field in Precompiled Contract Records

As an update to HIP-206 smart contracts will need to populate
the `contractCallResult` for all transaction records generated by precompiled
contracts recording key facts about the smart contract call. The semantics of
each field will be as follows:

- `contractID` will be set to the address of the precompile that generated the
  record.
- `gasUsed` will be set to the gas that the precompiled contract charged for its
  execution.
- `contractCallResult` will be populated with the return of the call, if any.
- `bloom` will be populated if the precompile produces EVM Logs.
- `logInfo` will be populated if the precompiled contract produces logs.
- `stateChanges` will be populated if the precompiled contract changes state in
  any contract.
- `createdContractIDs` will not be populated as it is not anticipated any 
  precompiled contracts will create new contracts.

### Replaying the Transaction

When replaying the transaction it is presumed the program has access to the
smart contracts deployed on the chain or can quickly address them on demand.
From this byte code along with precompiled system contract results a replay can
be performed.

First, all the read values of the storage changes are loaded into the local
world state. The entire state of the contracts involved are not needed and for
large contracts is not desirable for efficient execution.

Next the EVM operations are executed against this world state. For calls that go
to other contracts the bytecode is provided by the mirror node. For calls that
go to precompiled system contracts the results are mocked out by the related
record stream.

Finally, the execution can compare the record stream results with its own
results. This includes gas used and storage value changes.

A tracer can be attached to the EVM to capture intermediate data for
presentation by block explorers. Three kinds of data are most relevant. State
changes can be extracted from the record stream directly without replay.
Internal Transactions or "flat traces" can be calculated by storing select data
prior to a `CALL`, `DELEGATECALL`, `CALLCODE`, or `STATICCALL` operation and
then using that after the call returns to produce the flat trace. A full EVM
operation trace can be extracted in a similar manner.

Clients are encouraged to produce standard trace outputs, such as traces the
OpenEthereum Trace Module would produce or that EIP-3155 would produce.

## Backwards Compatibility

The added fields can be ignored by clients not wishing to trace or replay smart
contract transactions.

Prior transactions lacking these fields cannot be replayed efficiently, and will
require historical state reconstruction. This reflects current practice.

## Security Implications

All data stored can be recreated by anyone who already has full access to the
historical records. This EIP makes the data more efficient and economical to
access.

In adversarial conditions it is estimated the record stream can have 30 KB of
data added per million gas spent. This does not make smart contracts the most
efficient attack surface for record stream bloating.

Because we are not matching external gas pricing for our precompiled system
contracts we will be able to adjust the gas price of precompiled contracts if
they become an economical way to bloat the record stream size.

## How to Teach This

For creating a transaction replay clients should be pointed to the reference
implementation.

For end users looking for the benefits of state, flat, and operation traces user
help documentation and possibly a technical blog post should be sufficient.

## Reference Implementation

None yet. Expected no sooner than 0.22.0

## Rejected Ideas

### Trace Cross-contract calls in the record stream

The initial proposal included adding the full "flat trace" as a part of the
record. Early development showed that in adversarial interactions the record
stream would produce about one byte of data per unit of gas spent on the
transaction. When targeting millions of gas per second this would result in
megabytes of record data generated per second. This load in the record stream is
not sustainable for further scaling efforts.

## Open Issues

## References

- [OpenEthereum Trace Module](https://openethereum.github.io/JSONRPC-trace-module)
- [EIP-3155](https://eips.ethereum.org/EIPS/eip-3155) EVM trace specification

## Copyright/license

This document is licensed under the Apache License, Version 2.0 --
see [LICENSE](../LICENSE) or (https://www.apache.org/licenses/LICENSE-2.0)
